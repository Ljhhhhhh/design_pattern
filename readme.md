# 设计原则

---
## 单一职责原则

#### 原则核心：一个对象（方法）只做一件事情

#### 设计模式体现：

1. 代理模式：由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这两个对象之间起到中介的作用。
2. 迭代器模式：在不暴露对象内部结构的同时，可以顺序地访问聚合对象内部的元素。
3. 单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
4. 装饰者模式：在不改变原对象的基础上，通过对其进行包装拓展（添加属性或方法）使原有对象可以满足用户更复杂的需求。动态的给某个对象添加一些额外的职责，而不会影响从这个类派生的其他对象。

---
## 最少知识原则

#### 原则核心：一个软件实体应当尽可能少地与其他实体发生相互作用

#### 设计模式体现：

1. 中介者模式：通过中介者对象封装一系列对象之间的交互，使对象之间不再相互引用，降低他们之间的耦合。
2. 外观模式：为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易。
---
## 开放-封闭原则

####原则核心：软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改

#### 设计模式体现：

1. 观察者模式：（发布-订阅模式）定义对象间的一种一对多的依赖关系，对一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。
2. 模板方法模式：父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类中，使得子类可以不改变父类的算法结构的同时可以重新定义算法中的某些实现步骤。
3. 策略模式：定义一系列的算法，把它们一个个封装起来，并且使他们可以相互替换。
4. 代理模式：由于一个对象不能直接引用另外一个对象，所以需要通过代理对象在这两个对象之间起到中介的作用。
5. 职责链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

---

##其他设计模式
1. 命令模式：将请求与实现解耦并封装成独立对象，从而使不同的请求对客户端的实现参数化
2. 组合模式：（部分-整体模式）将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性
3. 享元模式：运用共享技术有效支持大量细粒度的对象，避免对象间拥有相同内容造成多余的开销
4. 状态模式：当一个对象的内部状态发生改变时，会导致其行为的改变，像是改变了对象。状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变。
5. 适配器模式：将一个类（对象）的接口（方法或者属性）转化成另外一个接口，解决两个软件实体间的接口不兼容问题，使原本由于接口不兼容而不能工作的两个软件实体可以一起工作
---

# 代码重构

1. 提炼函数
2. 合并重复的条件片段
3. 把条件分支语句提炼成函数
4. 合理使用循环
5. 提前让函数退出代替嵌套条件分支
6. 传递对象参数代替过长的参数列表
7. 尽量减少参数数量
8. 少用三目运算符
9. 合理使用链式调用
10. 分解大型类
11. 用return退出多重循环


